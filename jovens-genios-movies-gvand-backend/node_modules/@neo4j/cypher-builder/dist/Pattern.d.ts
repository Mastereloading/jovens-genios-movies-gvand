import type { NodeRef } from "./variables/NodeRef";
import type { RelationshipRef } from "./variables/RelationshipRef";
import type { CypherEnvironment } from "./Environment";
import type { Param } from "./variables/Param";
import type { CypherCompilable } from "./types";
export declare type MatchableElement = NodeRef | RelationshipRef;
declare type ItemOption = {
    labels?: boolean;
    variable?: boolean;
};
export declare type MatchPatternOptions = {
    source?: ItemOption;
    target?: ItemOption;
    relationship?: {
        type?: boolean;
        variable?: boolean;
    };
    directed?: boolean;
};
declare type ParamsRecord = Record<string, Param<any>>;
declare type MatchRelationshipParams = {
    source?: ParamsRecord;
    relationship?: ParamsRecord;
    target?: ParamsRecord;
};
export declare type MatchParams<T extends MatchableElement> = T extends NodeRef ? ParamsRecord : MatchRelationshipParams;
export declare class Pattern<T extends MatchableElement = MatchableElement> implements CypherCompilable {
    readonly matchElement: T;
    private parameters;
    private options;
    private reversed;
    constructor(input: T, options?: MatchPatternOptions);
    withParams(parameters: MatchParams<T>): this;
    getCypher(env: CypherEnvironment): string;
    /** Reverses the pattern direction, not the underlying relationship */
    reverse(): void;
    private isRelationshipPattern;
    private getRelationshipCypher;
    private getRelationshipArrows;
    private isRelationship;
    private getNodeCypher;
    private serializeParameters;
    private getNodeLabelsString;
    private getRelationshipTypesString;
}
export {};
//# sourceMappingURL=Pattern.d.ts.map