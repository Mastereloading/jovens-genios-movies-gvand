"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFieldAggregation = void 0;
const utils_1 = require("./utils");
const AggregationSubQueries = __importStar(require("./aggregation-sub-queries"));
const field_aggregations_auth_1 = require("./field-aggregations-auth");
const aggregation_sub_queries_1 = require("./aggregation-sub-queries");
const map_to_db_property_1 = __importDefault(require("../../utils/map-to-db-property"));
const create_where_and_params_1 = __importDefault(require("../where/create-where-and-params"));
const stringify_object_1 = require("../utils/stringify-object");
const apoc_run_1 = require("../utils/apoc-run");
const field_aggregation_composer_1 = require("../../schema/aggregations/field-aggregation-composer");
const upper_first_1 = require("../../utils/upper-first");
const get_relationship_direction_1 = require("../../utils/get-relationship-direction");
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const create_count_expression_1 = require("./create-count-expression");
const subqueryNodeAlias = "n";
const subqueryRelationAlias = "r";
function createFieldAggregation({ context, nodeLabel, node, field, }) {
    const relationAggregationField = node.relationFields.find((x) => {
        return `${x.fieldName}Aggregate` === field.name;
    });
    const connectionField = node.connectionFields.find((x) => {
        return `${relationAggregationField?.fieldName}Connection` === x.fieldName;
    });
    if (!relationAggregationField || !connectionField)
        return undefined;
    const referenceNode = (0, utils_1.getReferenceNode)(context, relationAggregationField);
    const referenceRelation = (0, utils_1.getReferenceRelation)(context, connectionField);
    if (!referenceNode || !referenceRelation)
        return undefined;
    const fieldPathBase = `${node.name}${referenceNode.name}${(0, upper_first_1.upperFirst)(relationAggregationField.fieldName)}`;
    const aggregationFields = getAggregationFields(fieldPathBase, field);
    const authData = (0, field_aggregations_auth_1.createFieldAggregationAuth)({
        node: referenceNode,
        context,
        subqueryNodeAlias,
        nodeFields: aggregationFields.node,
    });
    const [whereQuery, whereParams] = (0, create_where_and_params_1.default)({
        whereInput: field.args.where || {},
        varName: subqueryNodeAlias,
        node: referenceNode,
        context,
        recursing: true,
        chainStr: `${nodeLabel}_${field.alias}_${subqueryNodeAlias}`,
    });
    const targetPattern = createTargetPattern({
        nodeLabel,
        relationField: relationAggregationField,
        referenceNode,
        context,
        directed: field.args.directed,
    });
    const matchWherePattern = (0, aggregation_sub_queries_1.createMatchWherePattern)(targetPattern, authData, whereQuery);
    const apocRunParams = {
        ...(0, apoc_run_1.serializeParamsForApocRun)(whereParams),
        ...(0, utils_1.serializeAuthParamsForApocRun)(authData),
    };
    const sourceNode = new cypher_builder_1.default.NamedNode(nodeLabel);
    const targetNode = new cypher_builder_1.default.Node({ labels: referenceNode.getLabels(context) });
    const authCallWhere = new cypher_builder_1.default.RawCypher((env) => {
        const subqueryNodeName = targetNode.getCypher(env);
        const authDataResult = (0, field_aggregations_auth_1.createFieldAggregationAuth)({
            node: referenceNode,
            context,
            subqueryNodeAlias: subqueryNodeName,
            nodeFields: aggregationFields.node,
        });
        // TODO: refactor auth into cypherBuilder
        return [authDataResult.whereQuery, authDataResult.params];
    });
    const cypherParams = { ...authData.params, ...whereParams };
    const projectionMap = new cypher_builder_1.default.Map();
    if (aggregationFields.count) {
        const countProjection = (0, create_count_expression_1.createCountExpression)({
            sourceNode,
            relationAggregationField,
            referenceNode,
            context,
            field,
            authCallWhere,
            targetNode,
        });
        projectionMap.set({
            count: countProjection,
        });
    }
    const nodeFields = aggregationFields.node;
    if (nodeFields) {
        projectionMap.set({
            node: new cypher_builder_1.default.RawCypher(() => {
                return [
                    createAggregationQuery({
                        nodeLabel,
                        matchWherePattern,
                        fields: nodeFields,
                        fieldAlias: subqueryNodeAlias,
                        graphElement: referenceNode,
                        params: apocRunParams,
                    }),
                    cypherParams,
                ];
            }),
        });
    }
    const edgeFields = aggregationFields.edge;
    if (edgeFields) {
        projectionMap.set({
            edge: new cypher_builder_1.default.RawCypher(() => {
                return [
                    createAggregationQuery({
                        nodeLabel,
                        matchWherePattern,
                        fields: edgeFields,
                        fieldAlias: subqueryRelationAlias,
                        graphElement: referenceRelation,
                        params: apocRunParams,
                    }),
                    cypherParams,
                ];
            }),
        });
    }
    const rawProjection = new cypher_builder_1.default.RawCypher((env) => {
        return projectionMap.getCypher(env);
    });
    const result = rawProjection.build(`${nodeLabel}_${field.alias}_`);
    return { query: result.cypher, params: { ...result.params } };
}
exports.createFieldAggregation = createFieldAggregation;
function getAggregationFields(fieldPathBase, field) {
    const aggregationFields = field.fieldsByTypeName[`${fieldPathBase}${field_aggregation_composer_1.FieldAggregationSchemaTypes.field}`];
    const node = (0, utils_1.getFieldByName)("node", aggregationFields)?.fieldsByTypeName[`${fieldPathBase}${field_aggregation_composer_1.FieldAggregationSchemaTypes.node}`];
    const edge = (0, utils_1.getFieldByName)("edge", aggregationFields)?.fieldsByTypeName[`${fieldPathBase}${field_aggregation_composer_1.FieldAggregationSchemaTypes.edge}`];
    const count = (0, utils_1.getFieldByName)("count", aggregationFields);
    return { count, edge, node };
}
function createTargetPattern({ nodeLabel, relationField, referenceNode, context, directed, }) {
    const { inStr, outStr } = (0, get_relationship_direction_1.getRelationshipDirectionStr)(relationField, { directed });
    const nodeOutStr = `(${subqueryNodeAlias}${referenceNode.getLabelString(context)})`;
    return `(${nodeLabel})${inStr}[${subqueryRelationAlias}:${relationField.type}]${outStr}${nodeOutStr}`;
}
function createAggregationQuery({ nodeLabel, matchWherePattern, fields, fieldAlias, graphElement, params, }) {
    const fieldsSubQueries = Object.values(fields).reduce((acc, field) => {
        const fieldType = (0, utils_1.getFieldType)(field);
        const dbProperty = (0, map_to_db_property_1.default)(graphElement, field.name);
        const aggregationQuery = (0, apoc_run_1.wrapInApocRunFirstColumn)(getAggregationSubquery({
            matchWherePattern,
            fieldName: dbProperty || field.name,
            type: fieldType,
            targetAlias: fieldAlias,
        }), {
            ...params,
            [nodeLabel]: nodeLabel,
        });
        acc[field.alias] = `head(${aggregationQuery})`;
        return acc;
    }, {});
    return (0, stringify_object_1.stringifyObject)(fieldsSubQueries);
}
function getAggregationSubquery({ matchWherePattern, fieldName, type, targetAlias, }) {
    switch (type) {
        case utils_1.AggregationType.String:
        case utils_1.AggregationType.Id:
            return AggregationSubQueries.stringAggregationQuery(matchWherePattern, fieldName, targetAlias);
        case utils_1.AggregationType.Int:
        case utils_1.AggregationType.BigInt:
        case utils_1.AggregationType.Float:
            return AggregationSubQueries.numberAggregationQuery(matchWherePattern, fieldName, targetAlias);
        case utils_1.AggregationType.DateTime:
            return AggregationSubQueries.dateTimeAggregationQuery(matchWherePattern, fieldName, targetAlias);
        default:
            return AggregationSubQueries.defaultAggregationQuery(matchWherePattern, fieldName, targetAlias);
    }
}
//# sourceMappingURL=create-field-aggregation.js.map