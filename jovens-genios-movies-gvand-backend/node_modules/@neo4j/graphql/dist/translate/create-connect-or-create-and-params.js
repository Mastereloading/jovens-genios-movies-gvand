"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConnectOrCreateAndParams = void 0;
const classes_1 = require("../classes");
const create_auth_and_params_1 = require("./create-auth-and-params");
const constants_1 = require("../constants");
const utils_1 = require("../utils/utils");
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const callback_utils_1 = require("./utils/callback-utils");
const is_property_clash_1 = require("../utils/is-property-clash");
const create_connection_event_meta_1 = require("./subscriptions/create-connection-event-meta");
const filter_meta_variable_1 = require("./subscriptions/filter-meta-variable");
function createConnectOrCreateAndParams({ input, varName, parentVar, relationField, refNode, node, context, withVars, callbackBucket, }) {
    (0, utils_1.asArray)(input).forEach((connectOrCreateItem) => {
        const conflictingProperties = (0, is_property_clash_1.findConflictingProperties)({
            node: refNode,
            input: connectOrCreateItem.onCreate?.node,
        });
        if (conflictingProperties.length > 0) {
            throw new classes_1.Neo4jGraphQLError(`Conflicting modification of ${conflictingProperties.map((n) => `[[${n}]]`).join(", ")} on type ${refNode.name}`);
        }
    });
    const withVarsVariables = withVars.map((name) => new cypher_builder_1.default.NamedVariable(name));
    const statements = (0, utils_1.asArray)(input).map((inputItem, index) => {
        const subqueryBaseName = `${varName}${index}`;
        const result = createConnectOrCreatePartialStatement({
            input: inputItem,
            baseName: subqueryBaseName,
            parentVar,
            relationField,
            refNode,
            node,
            context,
            callbackBucket,
            withVars,
        });
        return result;
    });
    const wrappedQueries = statements.map((statement) => {
        const countResult = new cypher_builder_1.default.RawCypher(() => {
            if (context.subscriptionsEnabled) {
                return "meta as update_meta";
            }
            return "COUNT(*) AS _";
        });
        const returnStatement = new cypher_builder_1.default.Return(countResult);
        const withStatement = new cypher_builder_1.default.With(...withVarsVariables);
        const callStatement = new cypher_builder_1.default.Call(cypher_builder_1.default.concat(statement, returnStatement)).innerWith(...withVarsVariables);
        const subqueryClause = cypher_builder_1.default.concat(withStatement, callStatement);
        if (context.subscriptionsEnabled) {
            const afterCallWithStatement = new cypher_builder_1.default.With("*", [new cypher_builder_1.default.NamedVariable("update_meta"), "meta"]);
            cypher_builder_1.default.concat(subqueryClause, afterCallWithStatement);
        }
        return subqueryClause;
    });
    const query = cypher_builder_1.default.concat(...wrappedQueries);
    return query.build(`${varName}_`);
}
exports.createConnectOrCreateAndParams = createConnectOrCreateAndParams;
function createConnectOrCreatePartialStatement({ input, baseName, parentVar, relationField, refNode, node, context, callbackBucket, withVars, }) {
    const mergeQuery = mergeStatement({
        input,
        refNode,
        parentRefNode: node,
        context,
        relationField,
        parentNode: new cypher_builder_1.default.NamedNode(parentVar),
        varName: baseName,
        callbackBucket,
        withVars,
    });
    const authQuery = createAuthStatement({
        node: refNode,
        context,
        nodeName: baseName,
    });
    if (authQuery) {
        return cypher_builder_1.default.concat(mergeQuery, new cypher_builder_1.default.With("*"), authQuery);
    }
    return mergeQuery;
}
function mergeStatement({ input, refNode, parentRefNode, context, relationField, parentNode, varName, callbackBucket, withVars, }) {
    const whereNodeParameters = getCypherParameters(input.where?.node, refNode);
    const onCreateNodeParameters = getCypherParameters(input.onCreate?.node, refNode);
    const autogeneratedParams = getAutogeneratedParams(refNode);
    const node = new cypher_builder_1.default.NamedNode(varName, {
        labels: refNode.getLabels(context),
    });
    const unsetAutogeneratedParams = (0, utils_1.omitFields)(autogeneratedParams, Object.keys(whereNodeParameters));
    const callbackFields = getCallbackFields(refNode);
    const callbackParams = callbackFields
        .map((callbackField) => {
        const varNameVariable = new cypher_builder_1.default.NamedVariable(varName);
        return (0, callback_utils_1.addCallbackAndSetParamCypher)(callbackField, varNameVariable, parentNode, callbackBucket, "CREATE", node);
    })
        .filter((tuple) => tuple.length !== 0);
    const rawNodeParams = {
        ...unsetAutogeneratedParams,
        ...onCreateNodeParameters,
    };
    const onCreateParams = Object.entries(rawNodeParams).map(([key, param]) => {
        return [node.property(key), param];
    });
    const merge = new cypher_builder_1.default.Merge(node, whereNodeParameters).onCreate(...onCreateParams, ...callbackParams);
    const relationshipFields = context.relationships.find((x) => x.properties === relationField.properties);
    const autogeneratedRelationshipParams = relationshipFields ? getAutogeneratedParams(relationshipFields) : {};
    const rawOnCreateRelationshipParams = convertToCypherParams(input.onCreate?.edge || {});
    const rawRelationshipParams = {
        ...autogeneratedRelationshipParams,
        ...rawOnCreateRelationshipParams,
    };
    const relationship = new cypher_builder_1.default.Relationship({
        source: relationField.direction === "IN" ? node : parentNode,
        target: relationField.direction === "IN" ? parentNode : node,
        type: relationField.type,
    });
    const onCreateRelationshipParams = Object.entries(rawRelationshipParams).map(([key, param]) => {
        return [relationship.property(key), param];
    });
    const relationshipMerge = new cypher_builder_1.default.Merge(relationship).onCreate(...onCreateRelationshipParams);
    let withClause;
    if (context.subscriptionsEnabled) {
        const [fromTypename, toTypename] = relationField.direction === "IN" ? [refNode.name, parentRefNode.name] : [parentRefNode.name, refNode.name];
        withClause = new cypher_builder_1.default.RawCypher((env) => {
            const eventWithMetaStr = (0, create_connection_event_meta_1.createConnectionEventMeta)({
                event: "connect",
                relVariable: relationship.getCypher(env),
                fromVariable: relationship.source.getCypher(env),
                toVariable: relationship.target.getCypher(env),
                typename: relationField.type,
                fromTypename,
                toTypename,
            });
            return `WITH ${eventWithMetaStr}, ${(0, filter_meta_variable_1.filterMetaVariable)([...withVars, varName]).join(", ")}`;
        });
    }
    return cypher_builder_1.default.concat(merge, relationshipMerge, withClause);
}
function createAuthStatement({ node, context, nodeName, }) {
    if (!node.auth)
        return undefined;
    const auth = (0, create_auth_and_params_1.createAuthAndParams)({
        entity: node,
        operations: ["CONNECT", "CREATE"],
        context,
        allow: { parentNode: node, varName: nodeName, chainStr: `${nodeName}${node.name}_allow` },
        escapeQuotes: false,
    });
    if (!auth[0])
        return undefined;
    return new cypher_builder_1.default.RawCypher(() => {
        const predicate = `NOT (${auth[0]})`;
        const message = constants_1.AUTH_FORBIDDEN_ERROR;
        const cypherStr = `CALL apoc.util.validate(${predicate}, "${message}", [0])`;
        return [cypherStr, auth[1]];
    });
}
function getCallbackFields(node) {
    const callbackFields = node.primitiveFields.filter((f) => f.callback);
    return callbackFields;
}
// Helper for compatibility reasons
function getAutogeneratedParams(node) {
    const autogeneratedFields = node.primitiveFields
        .filter((f) => f.autogenerate)
        .reduce((acc, field) => {
        if (field.dbPropertyName) {
            acc[field.dbPropertyName] = new cypher_builder_1.default.RawCypher("randomUUID()");
        }
        return acc;
    }, {});
    const autogeneratedTemporalFields = node.temporalFields
        .filter((field) => ["DateTime", "Time"].includes(field.typeMeta.name) && field.timestamps?.includes("CREATE"))
        .reduce((acc, field) => {
        if (field.dbPropertyName) {
            acc[field.dbPropertyName] = new cypher_builder_1.default.RawCypher(`${field.typeMeta.name.toLowerCase()}()`);
        }
        return acc;
    }, {});
    return { ...autogeneratedTemporalFields, ...autogeneratedFields };
}
function getCypherParameters(onCreateParams = {}, node) {
    const params = Object.entries(onCreateParams).reduce((acc, [key, value]) => {
        const nodeField = node?.constrainableFields.find((f) => f.fieldName === key);
        const nodeFieldName = nodeField?.dbPropertyName || nodeField?.fieldName;
        const fieldName = nodeFieldName || key;
        const valueOrArray = nodeField?.typeMeta.array ? (0, utils_1.asArray)(value) : value;
        acc[fieldName] = valueOrArray;
        return acc;
    }, {});
    return convertToCypherParams(params);
}
// Based on cypher builder convertToCypherParams
function convertToCypherParams(original) {
    return Object.entries(original).reduce((acc, [key, value]) => {
        acc[key] = new cypher_builder_1.default.Param(value);
        return acc;
    }, {});
}
//# sourceMappingURL=create-connect-or-create-and-params.js.map