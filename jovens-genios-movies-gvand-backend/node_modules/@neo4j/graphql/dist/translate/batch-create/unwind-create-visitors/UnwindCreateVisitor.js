"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnwindCreateVisitor = void 0;
const create_relationship_validation_string_1 = __importDefault(require("../../create-relationship-validation-string"));
const utils_1 = require("../../../utils/utils");
const classes_1 = require("../../../classes");
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const map_to_db_property_1 = __importDefault(require("../../../utils/map-to-db-property"));
class UnwindCreateVisitor {
    constructor(unwindVar, callbackBucket, context) {
        this.unwindVar = unwindVar;
        this.callbackBucket = callbackBucket;
        this.context = context;
        this.environment = {};
    }
    visitCreate(create) {
        const labels = create.node.getLabels(this.context);
        const currentNode = new cypher_builder_1.default.Node({
            labels,
        });
        const setProperties = [...create.nodeProperties].map((property) => fieldToSetParam(create.node, currentNode, property, this.unwindVar.property(property)));
        const autogeneratedProperties = getAutoGeneratedFields(create.node, currentNode);
        const createClause = new cypher_builder_1.default.Create(currentNode).set(...setProperties, ...autogeneratedProperties);
        const relationshipValidationClause = new cypher_builder_1.default.RawCypher((env) => {
            const validationStr = (0, create_relationship_validation_string_1.default)({
                node: create.node,
                context: this.context,
                varName: env.getReferenceId(currentNode),
            });
            const cypher = [];
            if (validationStr) {
                cypher.push(`WITH ${env.getReferenceId(currentNode)}`);
                cypher.push(validationStr);
            }
            return cypher.join("\n");
        });
        let nestedClauses;
        if (create.children) {
            const childrenRefs = create.children.map((children) => {
                this.environment[children.id] = { unwindVar: this.unwindVar, parentVar: currentNode };
                children.accept(this);
                return children.id;
            });
            nestedClauses = childrenRefs.map((childrenRef) => this.environment[childrenRef].clause);
        }
        this.rootNode = currentNode;
        const clause = cypher_builder_1.default.concat(...(0, utils_1.filterTruthy)([
            createClause,
            ...nestedClauses,
            relationshipValidationClause,
            new cypher_builder_1.default.Return(currentNode),
        ]));
        this.clause = new cypher_builder_1.default.Call(clause).innerWith(this.unwindVar);
    }
    visitNestedCreate(nestedCreate) {
        const parentVar = this.environment[nestedCreate.id].parentVar;
        const unwindVar = this.environment[nestedCreate.id].unwindVar;
        if (!parentVar)
            throw new classes_1.Neo4jGraphQLError("Generic Error");
        const { node, relationship, relationshipPropertyPath } = nestedCreate;
        const blockWith = new cypher_builder_1.default.With(parentVar, unwindVar);
        const createUnwindVar = new cypher_builder_1.default.Variable();
        const createUnwindClause = new cypher_builder_1.default.Unwind([
            unwindVar.property(relationshipPropertyPath).property("create"),
            createUnwindVar,
        ]);
        const labels = node.getLabels(this.context);
        const currentNode = new cypher_builder_1.default.Node({
            labels,
        });
        const nodeVar = new cypher_builder_1.default.Variable();
        const edgeVar = new cypher_builder_1.default.Variable();
        const withCreate = new cypher_builder_1.default.With([createUnwindVar.property("node"), nodeVar], [createUnwindVar.property("edge"), edgeVar], parentVar);
        const createClause = new cypher_builder_1.default.Create(currentNode);
        if (!relationship[0]) {
            throw new classes_1.Neo4jGraphQLError("Nested created nodes should belong to a parent");
        }
        const relationshipClause = new cypher_builder_1.default.Relationship({
            source: currentNode,
            target: parentVar,
            type: relationship[0].type,
        });
        if (relationship[0].direction === "OUT") {
            relationshipClause.reverse();
        }
        const mergeClause = new cypher_builder_1.default.Merge(relationshipClause);
        const setPropertiesNode = nestedCreate.nodeProperties.map((property) => fieldToSetParam(node, currentNode, property, nodeVar.property(property)));
        const autogeneratedProperties = getAutoGeneratedFields(node, currentNode);
        createClause.set(...setPropertiesNode, ...autogeneratedProperties);
        if (nestedCreate.edgeProperties && nestedCreate.edgeProperties.length && nestedCreate.edge) {
            const setPropertiesEdge = nestedCreate.edgeProperties.map((property) => {
                return fieldToSetParam(nestedCreate.edge, relationshipClause, property, edgeVar.property(property));
            });
            const autogeneratedEdgeProperties = getAutoGeneratedFields(nestedCreate.edge, relationshipClause);
            mergeClause.set(...setPropertiesEdge, ...autogeneratedEdgeProperties);
        }
        const subQueryStatements = [blockWith, createUnwindClause, withCreate, createClause, mergeClause];
        const relationshipValidationClause = new cypher_builder_1.default.RawCypher((env) => {
            const validationStr = (0, create_relationship_validation_string_1.default)({
                node,
                context: this.context,
                varName: env.getReferenceId(currentNode),
            });
            const cypher = [];
            if (validationStr) {
                cypher.push(`WITH ${env.getReferenceId(currentNode)}`);
                cypher.push(validationStr);
            }
            return cypher.join("\n");
        });
        let nestedClauses;
        if (nestedCreate.children) {
            const childrenRefs = nestedCreate.children.map((children) => {
                this.environment[children.id] = { unwindVar: nodeVar, parentVar: currentNode };
                children.accept(this);
                return children.id;
            });
            nestedClauses = childrenRefs.map((childrenRef) => this.environment[childrenRef].clause);
            subQueryStatements.push(...nestedClauses);
        }
        subQueryStatements.push(relationshipValidationClause);
        subQueryStatements.push(new cypher_builder_1.default.Return([cypher_builder_1.default.collect(new cypher_builder_1.default.Literal(null)), new cypher_builder_1.default.Variable()]));
        const subQuery = cypher_builder_1.default.concat(...subQueryStatements);
        const callClause = new cypher_builder_1.default.Call(subQuery);
        const outsideWith = new cypher_builder_1.default.With(parentVar, unwindVar);
        this.environment[nestedCreate.id].clause = cypher_builder_1.default.concat(outsideWith, callClause);
    }
    /*
     * Returns the Cypher Reference of the root Nodes and the Cypher Clause generated
     */
    build() {
        return [this.rootNode, this.clause];
    }
}
exports.UnwindCreateVisitor = UnwindCreateVisitor;
function getAutoGeneratedFields(graphQLElement, cypherNodeRef) {
    const setParams = [];
    const timestampedFields = graphQLElement.temporalFields.filter((x) => ["DateTime", "Time"].includes(x.typeMeta.name) && x.timestamps?.includes("CREATE"));
    timestampedFields.forEach((field) => {
        // DateTime -> datetime(); Time -> time()
        const relatedCypherExpression = cypher_builder_1.default[field.typeMeta.name.toLowerCase()]();
        setParams.push([
            cypherNodeRef.property(field.dbPropertyName),
            relatedCypherExpression,
        ]);
    });
    const autogeneratedIdFields = graphQLElement.primitiveFields.filter((x) => x.autogenerate);
    autogeneratedIdFields.forEach((field) => {
        setParams.push([
            cypherNodeRef.property(field.dbPropertyName),
            cypher_builder_1.default.randomUUID(),
        ]);
    });
    return setParams;
}
function fieldToSetParam(graphQLElement, cypherNodeRef, key, value) {
    const pointField = graphQLElement.pointFields.find((x) => key === x.fieldName);
    const dbName = (0, map_to_db_property_1.default)(graphQLElement, key);
    if (pointField) {
        if (pointField.typeMeta.array) {
            const comprehensionVar = new cypher_builder_1.default.Variable();
            const mapPoint = cypher_builder_1.default.point(comprehensionVar);
            const expression = new cypher_builder_1.default.ListComprehension(comprehensionVar, value).map(mapPoint);
            return [cypherNodeRef.property(dbName), expression];
        }
        return [cypherNodeRef.property(dbName), cypher_builder_1.default.point(value)];
    }
    return [cypherNodeRef.property(dbName), value];
}
//# sourceMappingURL=UnwindCreateVisitor.js.map