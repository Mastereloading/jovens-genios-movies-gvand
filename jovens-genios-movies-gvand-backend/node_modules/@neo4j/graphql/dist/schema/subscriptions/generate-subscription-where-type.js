"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSubscriptionConnectionWhereType = exports.generateSubscriptionWhereType = void 0;
const RelationDirection_1 = require("../../graphql/enums/RelationDirection");
const to_compose_1 = require("../to-compose");
const upper_first_1 = require("../../utils/upper-first");
function generateSubscriptionWhereType(node, schemaComposer) {
    const typeName = node.name;
    const whereFields = (0, to_compose_1.objectFieldsToSubscriptionsWhereInputFields)(typeName, [
        ...node.primitiveFields,
        ...node.enumFields,
        ...node.scalarFields,
        ...node.temporalFields,
        ...node.pointFields,
    ]);
    return schemaComposer.createInputTC({
        name: `${node.name}SubscriptionWhere`,
        fields: whereFields,
    });
}
exports.generateSubscriptionWhereType = generateSubscriptionWhereType;
function generateSubscriptionConnectionWhereType({ node, schemaComposer, relationshipFields, interfaceCommonFields, }) {
    const fieldName = node.subscriptionEventPayloadFieldNames.connect;
    const typeName = node.name;
    let connectedNode = schemaComposer.getITC(`${typeName}SubscriptionWhere`);
    if (!connectedNode) {
        connectedNode = schemaComposer.createInputTC({
            name: `${typeName}SubscriptionWhere`,
            fields: (0, to_compose_1.objectFieldsToSubscriptionsWhereInputFields)(typeName, [
                ...node.primitiveFields,
                ...node.enumFields,
                ...node.scalarFields,
                ...node.temporalFields,
                ...node.pointFields,
            ]),
        });
    }
    return schemaComposer.createInputTC({
        name: `${typeName}ConnectionSubscriptionWhere`,
        fields: {
            [fieldName]: connectedNode,
            relationshipName: "String",
            direction: schemaComposer.createEnumTC(RelationDirection_1.RelationDirection),
            relationship: _getRelationshipConnectionWhereTypes({
                node,
                schemaComposer,
                relationshipFields,
                interfaceCommonFields,
            }),
        },
    });
}
exports.generateSubscriptionConnectionWhereType = generateSubscriptionConnectionWhereType;
function _getRelationshipConnectionWhereTypes({ node, schemaComposer, relationshipFields, interfaceCommonFields, }) {
    const { name, relationFields } = node;
    const relationsFieldInputWhereType = schemaComposer.getOrCreateITC(`${name}RelationshipsSubscriptionWhere`);
    relationFields.forEach((rf) => {
        const { fieldName } = rf;
        const nodeRelationPrefix = `${name}${(0, upper_first_1.upperFirst)(fieldName)}`;
        const relationFieldInputWhereType = schemaComposer.createInputTC({
            name: `${nodeRelationPrefix}RelationshipSubscriptionWhere`,
            fields: _makeNodeRelationFields({
                relationField: rf,
                schemaComposer,
                interfaceCommonFields,
                relationshipFields,
                nodeRelationPrefix,
            }),
        });
        relationsFieldInputWhereType.addFields({
            [fieldName]: relationFieldInputWhereType,
        });
    });
    return relationsFieldInputWhereType;
}
function _makeNodeRelationFields({ relationField, schemaComposer, interfaceCommonFields, relationshipFields, nodeRelationPrefix, }) {
    let edgeType;
    const relationProperties = relationshipFields.get(relationField.properties || "");
    if (relationProperties) {
        edgeType = schemaComposer.getOrCreateITC(`${relationField.properties}SubscriptionWhere`, (tc) => tc.addFields((0, to_compose_1.objectFieldsToSubscriptionsWhereInputFields)(relationField.properties, [
            ...relationProperties.primitiveFields,
            ...relationProperties.enumFields,
            ...relationProperties.scalarFields,
            ...relationProperties.temporalFields,
        ])));
    }
    const unionNodeTypes = relationField.union?.nodes;
    if (unionNodeTypes) {
        return unionNodeTypes.reduce((acc, unionFieldName) => {
            const unionFieldType = schemaComposer.getOrCreateITC(`${nodeRelationPrefix}${unionFieldName}SubscriptionWhere`, (tc) => tc.addFields({
                node: `${unionFieldName}SubscriptionWhere`,
                ...(edgeType && { edge: edgeType }),
            }));
            acc[unionFieldName] = unionFieldType;
            return acc;
        }, {});
    }
    const interfaceNodeTypes = relationField.interface?.implementations;
    if (interfaceNodeTypes) {
        const interfaceNodeTypeName = relationField.typeMeta.name;
        const interfaceImplementationsType = schemaComposer.getOrCreateITC(`${interfaceNodeTypeName}ImplementationsSubscriptionWhere`, (tc) => tc.addFields(interfaceNodeTypes.reduce((acc, nodeType) => {
            acc[nodeType] = `${nodeType}SubscriptionWhere`;
            return acc;
        }, {})));
        const interfaceCommonFieldsOnImplementations = interfaceCommonFields.get(interfaceNodeTypeName);
        const interfaceNodeType = schemaComposer.getOrCreateITC(`${interfaceNodeTypeName}SubscriptionWhere`, (tc) => tc.addFields({
            _on: interfaceImplementationsType,
            ...(interfaceCommonFieldsOnImplementations &&
                (0, to_compose_1.objectFieldsToSubscriptionsWhereInputFields)(interfaceNodeTypeName, [
                    ...interfaceCommonFieldsOnImplementations.primitiveFields,
                    ...interfaceCommonFieldsOnImplementations.enumFields,
                    ...interfaceCommonFieldsOnImplementations.scalarFields,
                    ...interfaceCommonFieldsOnImplementations.temporalFields,
                    ...interfaceCommonFieldsOnImplementations.pointFields,
                ])),
        }));
        return {
            node: interfaceNodeType,
            ...(edgeType && { edge: edgeType }),
        };
    }
    const nodeTypeName = relationField.typeMeta.name;
    return {
        node: `${nodeTypeName}SubscriptionWhere`,
        ...(edgeType && { edge: edgeType }),
    };
}
//# sourceMappingURL=generate-subscription-where-type.js.map